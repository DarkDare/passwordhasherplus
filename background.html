<!--
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Password Hasher Plus
 *
 * The Initial Developer of the Original Code is Eric Woodruff.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s): Oren Ben-Kiki
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
-->
<html>
<script type="text/javascript" src="common.js"></script>
<script type="text/javascript">

Storage.prototype.setObject = function (key, value) {
	this.setItem (key, JSON.stringify (value));
}

Storage.prototype.getObject = function (key) {
	var str = this.getItem (key);
	if (null == str) {
		throw "No object stored";
	}
	return JSON.parse (str);
}

Storage.prototype.getBoolean = function (key) {
	if ("true" == localStorage[key]) {
		return true;
	}
	return false;
}


migrate ();

var portsByTabId = {};

chrome.extension.onConnect.addListener (function (port) {
	console.assert (port.name == "passhash");
	port.onMessage.addListener (function (msg) {
		if (null != msg.init) {
			var url = grepUrl (msg.url);
			var config = loadConfig (url);
			port.passhashUrl = url;
			portsByTabId[port.tab.id] = port;
			port.postMessage ({ init: true, update: config });
		} else if (null != msg.save) {
			var url = grepUrl (msg.url);
			saveConfig (url, msg.save, null);
		}
	});

	port.onDisconnect.addListener (function (port) {
		if (null != port.tab) {
			delete portsByTabId[port.tab.id];
		}
	});
});

function saveConfig (url, config, tabid) {
	console.log ("Called saveConfig " + url);
	config.fields = toArray (config.fields);
	delete config.options;
	localStorage.setObject ("url:" + url, config);
	config.options = loadOptions ();

	if (null != tabid) {
		portsByTabId[tabid].postMessage ({ update: config });
	}
}

function loadOptions () {
	var dirty = false;
	var options;
	try {
		options = localStorage.getObject ("options");
	} catch (e) {
		options = new Object ();
		dirty = true;
	}
	if (null == options.privateSeed) {
		options.privateSeed = generateGuid ();
		dirty = true;
	}
	if (null == options.defaultLength) {
		options.defaultLength = default_length;
		dirty = true;
	}
	if (null == options.defaultStrength) {
		options.defaultStrength = default_strength;
		dirty = true;
	}
	if (null == options.backedUp) {
		options.backedUp = false;
		dirty = true;
	}
	if (null == options.compatibilityMode) {
		options.compatibilityMode = false;
		dirty = true;
	}
	if (dirty) {
		saveOptions (options);
	}
	return options;
}

function saveOptions (options) {
	localStorage.setObject ("options", options);
	var keys = toArray (localStorage);
	for (var i = 0; i < keys.length; ++i) {
		var key = keys[i];
		var port = portsByTabId[key];
		port.postMessage ({ update: loadConfig (port.passhashUrl) });
	}
}

function loadConfig (url) {
	console.log ("Called loadConfig " + url);

	var config;
	var options = loadOptions ();
	try {
		config = localStorage.getObject ("url:" + url);
	} catch (e) {
		config = new Object ();
		config.tag = url;
		config.length = options.defaultLength;
		config.strength = options.defaultStrength;
		config.fields = new Array ();
		config.seed = options.privateSeed;
	}
	config.options = loadOptions ();

	return config;
}

function grepUrl (url) {
	var reg = new RegExp ("^https?://([^:/]+?\\.)*?([^.:/]+)\\.([a-z]{2,15}(\\.[a-z]{2})?)(:\\d+)?/.*$");
	var m = reg.exec (url);
	try {
		if ("" == m[2]) {
			throw "chrome";
		}
		return m[2];
	} catch (e) {
		return 'chrome';
	}
}


function migrate () {
	migrate_v1 ();
	migrate_v2 ();
	migrate_v3 ();
	migrate_v4 ();
}

function migrate_v4 () {
	var version = parseInt (localStorage["version"]);
	if (4 <= version) {
		return;
	}

	var options = new Object ();
	options.defaultLength = localStorage["option:default_length"];
	options.defaultStrength = localStorage["option:default_strength"];
	options.privateSeed = localStorage["option:private_seed"];
	options.compatibilityMode = localStorage.getBoolean ("option:compatibility_mode");
	options.backedUp = localStorage.getBoolean ("option:backed_up");

	var keys = toArray (localStorage);
	for (var i = 0; i < keys.length; ++i) {
		var key = keys[i];
		if (key.startsWith ("option:")) {
			delete localStorage[key];
		} else if (key.startsWith ("url:")) {
			var config = localStorage.getObject (key);
			try {
				if (config.tag.startsWith ("compatible:")) {
					delete config.seed;
					config.tag = config.tag.substringAfter ("compatible:");
				}
				delete config.compatibilitymode;
				delete config.backedup;
				localStorage.setObject (key, config);
			} catch (e) {
				console.log ("failed to migrate " + key);
			}
		}
	}

	saveOptions (options);

	localStorage["version"] = "4";
}

function migrate_v3 () {
	var version = parseInt (localStorage["version"]);
	if (3 <= version) {
		return;
	}

	var keys = toArray (localStorage);
	for (var i = 0; i < keys.length; ++i) {
		var key = keys[i];
		if (!key.startsWith ("url:")) {
			continue;
		}
		try {
			var config = localStorage.getObject (key);
			var config2 = new Object ();
			config2.tag = config.site;
			for (var property in config) {
				config2[property] = config[property];
			}
			delete config2.site;
			localStorage.setObject (key, config2);
		} catch (e) {
			console.log ("failed to migrate " + key);
		}
	}

	localStorage["version"] = "3";
}

function migrate_v2 () {
	var version = parseInt (localStorage["version"]);
	if (2 <= version) {
		return;
	}

	var keys = toArray (localStorage);
	var reg = new RegExp ("^site:.*$");
	for (var i = 0; i < keys.length; ++i) {
		var key = keys[i];
		if (reg.test (key)) {
			var to = "url";
			localStorage[to + key.slice(4)] = localStorage[key];
			delete localStorage[key];
		}
	}
	
	localStorage["version"] = "2";
}

function migrate_v1 () {
	if (null == localStorage["version"] && null != localStorage["option:private_seed"]) {
		// Migrate Password Hasher Plus Plus databases
		localStorage["version"] = "1";
	}

	var version = parseInt (localStorage["version"]);
	if (Number.NaN != version && 1 <= version) {
		return;
	}

	var keys = toArray (localStorage);

	var reg = new RegExp ("^compatibility_mode|default_length|default_strength|private_seed|backed_up$");
	for (var i = 0; i < keys.length; ++i) {
		var key = keys[i];
		var to = "site";
		if (reg.test (key)) {
			to = "option";
		}
		localStorage[to + ":" + key] = localStorage[key];
		delete localStorage[key];
	}
	
	localStorage["version"] = "1";
}

</script>
</html>
